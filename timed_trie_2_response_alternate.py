# -*- coding: utf-8 -*-
"""timed_trie_2_response_alternate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1siixg1gbp-Jv0SZe0cbkvlIohQ6n09av

# Timed Trie (response/alternate/... analysis)
This notebook is for application of timmed trie on (response/alternate/...) trace
"""

# !pip install -q rstr;
# !pip install -q pyvis;
# !apt-get -qq install graphviz graphviz-dev -y && pip install -q pygraphviz;

import matplotlib.pyplot as plt
from graphviz import Digraph
import numpy as np
import pandas as pd

import rstr
import random
import sys
import seaborn
import statistics
import difflib
import time
from typing import Tuple

"""# Import file

# Utility functions
"""


def getNodeId(node_id: str):
    if len(node_id.split("_")) > 1:
        return str(int(node_id.split("_")[1]) - 1);

    return "-1"


def getStateId(node_id: str):
    return "q_" + getNodeId((node_id));


"""# Mine for properties

## Trace Generation
"""


# Get trace and the associated event time. This follows a strict regex pattern
def getTrace(pattern='ab+ac', startTime=0, windowTimeLength=15):
    time = []
    prev = startTime  # scalar shift by startTime
    generate_trace = True

    while generate_trace:
        generate_trace = False

        trace = rstr.xeger(pattern)
        while len(trace) > windowTimeLength:
            trace = rstr.xeger(pattern)
            print("trace ", trace)

        print("Trace generated ", trace)
        # time = list(range(1, 1+len(trace), 2))
        for i in range(0, len(trace)):
            try:
                roomToMove = max(10, windowTimeLength - (len(trace) - len(time)) - prev)
                curr = random.randint(prev + 1, prev + roomToMove)
                time.append(curr)
                prev = curr
                # print(roomToMove, prev)
            except ValueError:
                print('Event-Time creation: Value Error. Restarting...')
                time.clear()
                prev = 0
                generate_trace = True
                break

    return trace, time


def getTimeShift(time):
    time_new = [0]
    for i in range(1, len(time)):
        time_diff = max(0, time[i] - time[i - 1])
        time_new.append((time_diff))

    return time_new


def completeTrace(pattern='ab+ac', times=2, windowTimeLength=15, local_clock=False):
    trace, time = "", [];
    prev = 0;

    for _ in range(times):
        _trace, _time = getTrace(pattern, prev, windowTimeLength)
        trace += _trace
        time.extend(_time)

        prev = time[-1]
        print("prev time ", time)

    if local_clock:
        time = getTimeShift(time)

    return trace, time


abc_test = [1, 2, 3, 4]
abc_test[-1]

"""#### Hyperparameter"""

STD_VAL = 0.675  # within the interquartile range
K = 15
TRACE_SEQUENCE_REPETITION_COUNT = 1
WINDOW_LENGTH = 50
global_node_count = 0
threshold_prob = 0.50

"""#### Generate Synthetic trace"""

# regex_trace = "ab+ac"
# regex_trace = "c+(ac+bc+)+"
regex_trace_response = "([bz]*(a[a-cz]*b[bz]*)){1,2}"
regex_trace_response_restricted = "([bz]{0,2}(a[a-cz]{0,5}b[bz]{0,2})){3,15}"

regex_trace_alternating = "[cz]*(a[ca]*b[cz]*)*"
regex_trace_alternating_restricted = "[c-z]{0,2}(a[c-z]{0,2}b[c-z]{0,2}){2,3}"

trace, trace_time = completeTrace(regex_trace_alternating_restricted, TRACE_SEQUENCE_REPETITION_COUNT, WINDOW_LENGTH,
                                  True)
print("Trace length : ", len(trace))
print("trace ", trace, "\ntime", trace_time)
timed_trace = (list(trace), trace_time)

"""#### Import Hexcopter trace"""
#
# trace = list(hil_RF_Baseline_Clean_df['event'])
# trace_time = getTimeShift(list(hil_RF_Baseline_Clean_df['time']))
# timed_trace = (list(trace), trace_time)
#
# trace_clean2 = list(hil_RF_Baseline_Clean2_df['event'])
# trace_time_clean2 = getTimeShift(list(hil_RF_Baseline_Clean2_df['time']))
# timed_trace_clean2 = (list(trace_clean2), trace_time_clean2)
#
# trace_faulty = list(hil_FaultInj_s_df['event'])
# trace_faulty_time = getTimeShift(list(hil_FaultInj_s_df['time']))
# timed_trace_faulty = (list(trace_faulty), trace_faulty_time)

"""## Create Timed Trie

### Define
"""


class TrieNode(object):
    def __init__(self, id: int, char: str):
        self.node_id = "Node_" + str(id)
        self.char = char
        self.children = []
        self.count = 1
        self.t_min = sys.maxsize
        self.t_max = 0
        self.t_mean = 0
        self.t_list = []
        self.t_var = 0
        self.dropped = 0
        self.prob = 0.0
        self.is_end = True


def traverseAndBuild(node: TrieNode, trace: (list(), list()), pos: int):
    if pos >= len(trace[0]):
        return

    global global_node_count
    node.is_end = False
    event, time = trace[0][pos: pos + 1], trace[1][pos: pos + 1]
    event, time = event[0], time[0]
    # print(event, time)
    found = False
    doTimeCheck = True if pos < len(trace[0]) - 1 else False

    for child in node.children:
        if child.char == event:  # check with character only
            if doTimeCheck == False or (doTimeCheck == True and time >= child.t_min and time <= child.t_max):
                found = True
                child.count += 1
                child.t_min = min(child.t_min, time)
                child.t_max = max(child.t_max, time)
                child.t_list.append(time)
                traverseAndBuild(child, trace, pos + 1)
                return

    if not found and doTimeCheck == False:  # only create for last element in the trace
        global_node_count += 1
        newNode = TrieNode(global_node_count, event)
        newNode.t_min = time
        newNode.t_max = time
        newNode.t_list.append(time)
        node.children.append(newNode)
        traverseAndBuild(newNode, trace, pos + 1)


def evaluateProb(node: TrieNode, d: int, current_d: int):
    if current_d > d:
        return

    tot_count = 1
    for _child in node.children:
        tot_count += _child.count

    for child in node.children:
        child.prob = round(float(child.count / tot_count), 2)

    for child in node.children:
        evaluateProb(child, d, current_d + 1)


def evaluateAtDepth(node: TrieNode, d: int, current_d: int):
    if d <= 1:
        return

    global STD_VAL
    if current_d < d - 1:
        for child in node.children:
            evaluateAtDepth(child, d, current_d + 1)
    else:
        node.t_mean = statistics.mean(node.t_list)
        node.t_var = statistics.pstdev(node.t_list)
        _var = STD_VAL * node.t_var
        node.t_min, node.t_max = node.t_mean - _var, node.t_mean + _var
        node.t_min, node.t_max = round(node.t_min), round(node.t_max)
        # print("node.t_min ", node.t_min, "  node.t_max  ", node.t_max)

        # Take inner quartile
        node.count = sum(ele >= node.t_min and ele <= node.t_max for ele in node.t_list)
        node.dropped = len(node.t_list) - node.count


def buildGraph(timed_trace, K: int = 3) -> TrieNode:
    global global_node_count
    global_node_count += 1

    root = TrieNode(global_node_count, "*")
    for k in range(1, K + 1):
        for i in range(0, len(timed_trace[0]) - k):
            sub_trace_event = timed_trace[0][i: i + k]
            sub_trace_time = timed_trace[1][i: i + k]
            sub_trace_time[0] = 0  # Fix for start event time

            sub_trace = (sub_trace_event, sub_trace_time)
            # print(sub_trace)
            traverseAndBuild(root, sub_trace, 0)
        evaluateAtDepth(root, k, 0)

    evaluateProb(root, K, 0)

    return root


"""### Perform Mining"""

start = time.time()

timed_trie = buildGraph(timed_trace, K)
time_diff = round(time.time() - start, 2)
print("Timed to buildGraph : ", str(time_diff), " sec")

timed_trie

"""# Generate Digraph for Timed Trie

#### Digraph visualizer
"""


def traverseAndCreaseDigraph(dot: Digraph, node: TrieNode, state_graph=False):
    parent_id = node.char if not state_graph else getStateId(node.node_id)

    if not node.children:
        dot.attr('node', shape="doublecircle")
    else:
        dot.attr('node', shape="circle")

    dot.node(node.node_id, parent_id)

    tot_count = 1
    for _child in node.children:
        tot_count += _child.count

    for child in node.children:

        prefix = "" if not state_graph else (child.char + " , ");
        edge_label = prefix + "[" + str(child.t_min) + "," + str(child.t_max) + "]";
        if state_graph:
            edge_label += " , " + str(child.prob)
        else:
            edge_label += " { Count : " + str(child.count) + " Dropped : " + str(child.dropped) + " }";

        child_id = child.char if not state_graph else getStateId(child.node_id)

        if not child.children:
            dot.attr('node', shape="doublecircle")
        else:
            dot.attr('node', shape="circle")

        dot.node(child.node_id, child_id)

        dot.edge(node.node_id, child.node_id, label=edge_label)
        traverseAndCreaseDigraph(dot, child, state_graph)


def visualizeTrie(timed_trie: TrieNode, state_graph=False):
    dot = Digraph(comment='Timed Trie', format='png')
    traverseAndCreaseDigraph(dot, timed_trie, state_graph)
    return dot


"""## Visualize"""
#
# timed_trie_viz = visualizeTrie(timed_trie,True)
# timed_trie_viz.render('timed_trie_state_diagram.gv', view=True)
# timed_trie_viz
#
# timed_trie_viz = visualizeTrie(timed_trie,False)
# timed_trie_viz.render('timed_trie.gv', view=True)
# timed_trie_viz

"""### Extract expression"""


def extractPattern(node: TrieNode, max_d: int, current_d: int):
    patterns = []

    if current_d > max_d:
        return patterns;

    global threshold_prob

    currentPattern = ""

    for child in node.children:
        if child.prob >= threshold_prob or current_d == 0:
            if current_d > 0:
                currentPattern = "[" + str(child.t_min) + "," + str(child.t_max) + "]"
            else:
                currentPattern = "[-INF," + str(child.t_max) + "]"

            currentPattern += child.char + " "

            inner_patterns = extractPattern(child, max_d, current_d + 1)
            if len(inner_patterns) > 0:
                currentPattern = [currentPattern + ele for ele in inner_patterns]
            else:
                currentPattern = [currentPattern]

            patterns.extend(currentPattern)

    return patterns


# threshold_prob = 0.60
possiblePatterns = extractPattern(timed_trie, K, 0)

print("Possible Patterns (count) : {0}  Threshold : {1}".format(str(len(possiblePatterns)), str(threshold_prob)))
for ele in possiblePatterns:
    print(ele)

"""# Test Model"""


def getTestData(timed_trace, K: int = 3):
    test = []

    substring_end = max(1, len(timed_trace[0]) - K)
    while len(test) < 0.3 * substring_end:
        i_pos = random.randint(0, substring_end)
        sub_event = timed_trace[0][i_pos:i_pos + K]
        sub_time = timed_trace[1][i_pos:i_pos + K]
        sub_time[0] = 0  # fix for start event time

        sub_trace = (sub_event, sub_time)
        test.append((sub_trace, 1))

    return test


def predict(timed_trie: TrieNode, sub_trace):
    root = timed_trie
    sub_trace[1]

    def _traverse(node: TrieNode, sub_trace, pos):
        if pos == len(sub_trace[0]):
            return 1

        _event, _time = sub_trace[0][pos: pos + 1], sub_trace[1][pos: pos + 1]
        _event, _time = _event[0], _time[0]

        for child in node.children:
            if child.char == _event and child.t_min <= _time and _time <= child.t_max:
                return _traverse(child, sub_trace, pos + 1)

        return 0

    return _traverse(timed_trie, sub_trace, 0)


def evaluate_model(timed_trie: TrieNode, test_dataset):
    true_y = [b[1] for b in test_dataset]
    predict_y = []
    for _sub_trace in test_dataset:
        predicted_val = predict(timed_trie, _sub_trace[0])
        predict_y.append(predicted_val)

    # print(test_dataset)
    # print("Predicted_y ", predict_y)
    # print("True_y ", true_y)

    incorrect_indexes = []
    for i in range(len(true_y)):
        if true_y[i] != predict_y[i]:
            incorrect_indexes.append(i)

    incorrectSequences = []
    for _i in incorrect_indexes:
        incorrectSequences.append(test_dataset[_i][0])

    # print("Total test cases ", str(len(true_y)), " Incorrect length ", str(len(incorrectSequences)))
    # print(" Incorrect Sequences ", incorrectSequences)
    accuracy = 1 - len(incorrectSequences) / len(test_dataset)
    accuracy = round(accuracy, 4)
    # print("Accuracy ", str(accuracy))
    return accuracy


def evaluate_accuracy(timed_trace, K, timed_trie: TrieNode, attempts: int = 5):
    accuracy_list = []
    test_dataset_len = []
    for i in range(attempts + 1):
        test_dataset = getTestData(timed_trace, K)
        test_dataset_len.append((len(test_dataset)))

        if len(test_dataset) == 0:
            continue

        accuracy = evaluate_model(timed_trie, test_dataset)
        accuracy_list.append(100 * accuracy)

    print("Test Dataset Length (avg) ", str(round(np.mean(test_dataset_len))))
    return accuracy_list


accuracy_trials = evaluate_accuracy(timed_trace, K, timed_trie, 10)
print("Accuracy : " + str(
    round(statistics.mean(accuracy_trials), 2) if len(accuracy_trials) > 1 else accuracy_trials[0]) + " % ")
print("Accuracy List " + ', '.join(str(round(e, 2)) for e in accuracy_trials))

# accuracy_trials_clean2 = evaluate_accuracy(timed_trace_clean2, K, timed_trie, 3)
# print("Accuracy (clean 2) : " + str(round(statistics.mean(accuracy_trials_clean2), 2)) + " % ")
# print("Accuracy List (clean 2) " + ', '.join(str(round(e, 2)) for e in accuracy_trials_clean2))
#
# accuracy_trials_faulty = evaluate_accuracy(timed_trace_faulty, K, timed_trie, 3)
# print("Accuracy (Faulty) : " + str(round(statistics.mean(accuracy_trials_faulty), 2)) + " % ")
# print("Accuracy List (Faulty) " + ', '.join(str(round(e, 2)) for e in accuracy_trials_faulty))